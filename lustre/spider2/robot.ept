open Lib

fun mux(x : bool ; y, z : float) returns (r : float);
let
    r = if x then y else z;
tel

fun sgn(x : float) returns (r : float);
let 
    r = if x >. 0.0 then 1.0 else (if x <. 0.0 then -.1.0 else 0.0);
tel

fun setMotor(current : float; goal : float ; maxi : float) returns (power : float);
var delta : float; delta2 : float;
let 
    delta = fmod(goal -. current, 360.0);
    delta2 = if abs(delta) <=. 0.1 then 0.0 else delta;
    (*power = if abs(delta) >=. 20.0 then -.maxi *.sgn(delta) *. 0.1 else -.delta;*)
    power = if delta2 <. 180.0 then min(abs(delta2),maxi) else -.min(abs(delta2), maxi);
tel

fun setMotorFast(current : float; goal : float ; maxi : float) returns (power : float);
var delta : float;
let 
    delta = fmod(goal -. current, 360.0);
    power = if delta <. 180.0 then maxi else -.maxi;
tel
node setMotorPID(
    currentAngle: float; 
    goalAngle: float; 
    maxSpeed: float; 
    kp: float; 
    ki: float; 
    kd: float;
) returns (motorSpeed: float);
var
    error: float;
    integral: float;
    derivative: float;
    lastError: float;
    rawSpeed: float;
let
    error = goalAngle -. currentAngle;
    integral = 0.0 -> pre integral +. error;
    derivative = 0.0 -> (error -. pre lastError);
    rawSpeed = (kp *. error) +. (ki *. integral) +. (kd *. derivative);
    motorSpeed = if rawSpeed >. maxSpeed then maxSpeed 
                 else if rawSpeed <. -.maxSpeed then -.maxSpeed 
                 else if abs(rawSpeed) <. 0.1 then 0.0
                 else rawSpeed;
    lastError = error;
tel


(*
fun step( hipLangle, hipRangle, kneeLangle, kneeRangle, gyroscope : float ; goLeft : bool ) returns (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed : float);
var hipLgoal, hipRgoal, kneeLgoal, kneeRgoal : float;
let
    hipLgoal = mux(goLeft, -.0.0, -.80.0);
    hipRgoal = mux(goLeft, 80.0, 0.0);
    kneeLgoal = mux(goLeft, 20.0, 80.0);
    kneeRgoal = mux(goLeft, -.80.0, -.20.0);

    hipLspeed = setMotor(hipLangle, hipLgoal, 60.0);
    hipRspeed = setMotor(hipRangle, hipRgoal, 60.0);
    kneeLspeed = setMotor(kneeLangle +. hipLgoal, kneeLgoal, 300.0);
    kneeRspeed = setMotor(kneeRangle +. hipRgoal, kneeRgoal, 300.0);
tel
*)

fun doNotMove(limit, speedA, speedB, speedC, speedD : float) returns (ok : bool);
let
    ok = (speedA <=. limit) and (speedB <=. limit) and (speedC <=. limit) and (speedD <=. limit);
tel

node setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, arm1goal, arm2goal, arm3goal, arm4goal : float) returns (arm1speed, arm2speed, arm3speed, arm4speed : float);
let
    arm1speed = setMotorPID(arm1angle, arm1goal, 20.0, 0.5, 0.0, 0.2);
    arm2speed = setMotorPID(arm2angle, arm2goal, 20.0, 0.7, 0.0, 0.3);
    arm3speed = setMotorPID(arm3angle, arm3goal, 20.0, 0.9, 0.0, 0.4);
    arm4speed = setMotorPID(arm4angle, arm4goal, 20.0, 1.0, 0.0, 0.5);
tel

node setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, hipLgoal, hipRgoal, kneeLgoal, kneeRgoal : float) returns (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed : float);
let
    hipLspeed = setMotor(hipLangle, hipLgoal, 60.0);
    hipRspeed = setMotor(hipRangle, hipRgoal, 60.0);
    kneeLspeed = setMotor(kneeLangle, kneeLgoal, 60.0);
    kneeRspeed = setMotor(kneeRangle, kneeRgoal, 60.0);
tel



node robot(dt : float;
           hipLangle : float;
           hipRangle : float;
           kneeLangle : float;
           kneeRangle : float;
           arm1angle : float;
           arm2angle : float;
           arm3angle : float;
           arm4angle : float;
           gyroscopeTot : float;
           calfLdistance : float;
           calfRdistance : float;
           bodyDistance : float;
           footLcontact : bool;
           footRcontact : bool;
           bodyContact : bool;
           main_x : float;
           main_y : float;
           secondary_x : float;
           secondary_y : float;
           action_a : bool
)
returns (  hipLspeed : float;
           hipRspeed : float;
           kneeLspeed : float;
           kneeRspeed : float;
           arm1speed : float;
           arm2speed : float;
           arm3speed : float;
           arm4speed : float;
           arm_target_x : float;
           arm_target_y : float;
);
var gyroscope : float; dgyroscope : float;
let
    gyroscope = fmod(gyroscopeTot, 360.0);
    dgyroscope = 100.0 -> abs(gyroscope -. pre gyroscope) /. dt;

    arm_target_x = clamp(   0.0 -> pre arm_target_x +. (secondary_x *. dt *. 0.5) , -.1.0, 1.0);
    arm_target_y = clamp(   0.2 -> pre arm_target_y +. (secondary_y *. dt *. 0.5) , 0.25, 1.0);

    (* This first automaton is used when you need to control the legs and the arm at the same time *)
    automaton
        state Falling
            do
                (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) =
                    setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, -.40.0, 40.0, 100.0, -.100.0);
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, -.40.0, 30.0 , 80.0, 60.0);

            until footLcontact or footRcontact or bodyContact then Standard

        state Upside_Down_Init
            var isStatic : bool;
            do
                (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) =
                    setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, -.40.0, 40.0, 100.0, -.100.0);
 
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, -.0.0, 0.0 , 0.0, 0.0);

                isStatic = doNotMove(1.0, hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) and doNotMove(1.0, arm1speed, arm2speed, arm3speed, arm4speed) ;
                until isStatic and gyroscope >=. 180.0 then Upside_Down_Left
                    | isStatic and gyroscope <. 180.0 then Upside_Down_Right

        state Upside_Down_Left
            var time : float;
            do
                time = 0.0 -> pre time +. dt;

                (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) =
                    setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, 60.0, 40.0, 40.0, -.100.0);
 
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, -.65.0, -.0.0 , -.10.0, -.30.0);
                
                until gyroscope <=. 40.0 or gyroscope >=. 320.0 then Standard
                    | doNotMove(0.1, arm1speed, arm2speed, arm3speed, arm4speed) and arm1angle <=. -.20.0 and dgyroscope <=. 1.0 and time >=. 5.0 then Upside_Down_Right

        state Upside_Down_Right
            var time : float;
            do
                time = 0.0 -> pre time +. dt;

                (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) =
                    setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, -.40.0, -.60.0, 100.0, -.40.0);
 
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, 65.0, 0.0 , 10.0, 30.0);

                until gyroscope <=. 40.0 or gyroscope >=. 320.0 then Standard
                    | doNotMove(0.1, arm1speed, arm2speed, arm3speed, arm4speed) and arm1angle >=. 20.0 and dgyroscope <=. 1.0 and time >=. 5.0 then Upside_Down_Left

        state Jump
            do
                hipLspeed = setMotorFast(hipLangle, 90.0, 300.0);
                hipRspeed = setMotorFast(hipRangle, -.90.0, 300.0);
                kneeLspeed = setMotorFast(kneeLangle +. hipLangle +. gyroscope, 90.0, 300.0);
                kneeRspeed = setMotorFast(kneeRangle +. hipRangle +. gyroscope, -.90.0, 300.0);
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, -.10.0, 10.0 , -.10.0, 10.0);

            until not footLcontact and not footRcontact then Falling


        state Standard
            var theta1 : float; theta2 : float; theta3 : float; theta4 : float;
            do
                (* control the legs *)

                (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed) =
                    setMotorLegs(hipLangle, hipRangle, kneeLangle, kneeRangle, -.40.0, 40.0, 100.0, -.100.0);
                
                (* control the arm *)
                (* (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, -.40.0, 30.0 , 80.0, 60.0); *)

                (theta1, theta2, theta3, theta4) = arm_ik (arm_target_x, arm_target_y ,0.0, arm1angle, arm2angle, arm3angle, arm4angle, 0.26, 0.26, 0.26, 0.26);
                (arm1speed, arm2speed, arm3speed, arm4speed) =
                    setMotorArm(arm1angle, arm2angle, arm3angle, arm4angle, theta1, theta2 , theta3, theta4);


            until gyroscope >=. 90.0 and gyroscope <=. 260.0 then Upside_Down_Init
                | action_a then Jump
    end;
tel
