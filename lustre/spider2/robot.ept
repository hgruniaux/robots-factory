open Lib

fun mux(x : bool ; y, z : float) returns (r : float);
let
    r = if x then y else z;
tel

fun sgn(x : float) returns (r : float);
let 
    r = if x >. 0.0 then 1.0 else (if x <. 0.0 then -.1.0 else 0.0);
tel

fun setMotor(current : float; goal : float ; maxi : float) returns (power : float);
var delta : float;
let 
    delta = fmod(goal -. current, 360.0);
    (*power = if abs(delta) >=. 20.0 then -.maxi *.sgn(delta) *. 0.1 else -.delta;*)
    power = if delta <. 180.0 then min(abs(delta),maxi) else -.min(abs(delta), maxi);
tel

fun setMotorFast(current : float; goal : float ; maxi : float) returns (power : float);
var delta : float;
let 
    delta = fmod(goal -. current, 360.0);
    power = if delta <. 180.0 then maxi else -.maxi;
tel
node setMotorPID(
    currentAngle: float; 
    goalAngle: float; 
    maxSpeed: float; 
    kp: float; 
    ki: float; 
    kd: float;
) returns (motorSpeed: float);
var
    error: float;
    integral: float;
    derivative: float;
    lastError: float;
    rawSpeed: float;
let
    error = goalAngle -. currentAngle;
    integral = 0.0 -> pre integral +. error;
    derivative = 0.0 -> (error -. pre lastError);
    rawSpeed = (kp *. error) +. (ki *. integral) +. (kd *. derivative);
    motorSpeed = if rawSpeed >. maxSpeed then maxSpeed 
                 else if rawSpeed <. -.maxSpeed then -.maxSpeed 
                 else rawSpeed;
    lastError = error;
tel


(*
fun step( hipLangle, hipRangle, kneeLangle, kneeRangle, gyroscope : float ; goLeft : bool ) returns (hipLspeed, hipRspeed, kneeLspeed, kneeRspeed : float);
var hipLgoal, hipRgoal, kneeLgoal, kneeRgoal : float;
let
    hipLgoal = mux(goLeft, -.0.0, -.80.0);
    hipRgoal = mux(goLeft, 80.0, 0.0);
    kneeLgoal = mux(goLeft, 20.0, 80.0);
    kneeRgoal = mux(goLeft, -.80.0, -.20.0);

    hipLspeed = setMotor(hipLangle, hipLgoal, 60.0);
    hipRspeed = setMotor(hipRangle, hipRgoal, 60.0);
    kneeLspeed = setMotor(kneeLangle +. hipLgoal, kneeLgoal, 300.0);
    kneeRspeed = setMotor(kneeRangle +. hipRgoal, kneeRgoal, 300.0);
tel
*)

fun do_not_move(limit, speedA, speedB, speedC, speedD : float) returns (ok : bool);
let
    ok = (speedA <=. limit) and (speedB <=. limit) and (speedC <=. limit) and (speedD <=. limit);
tel


node robot(dt : float;
           hipLangle : float;
           hipRangle : float;
           kneeLangle : float;
           kneeRangle : float;
           arm1angle : float;
           arm2angle : float;
           arm3angle : float;
           arm4angle : float;
           gyroscope : float;
           calfLdistance : float;
           calfRdistance : float;
           footLcontact : bool;
           footRcontact : bool;
           bodyContact : bool
)
returns (  hipLspeed : float;
           hipRspeed : float;
           kneeLspeed : float;
           kneeRspeed : float;
           arm1speed : float;
           arm2speed : float;
           arm3speed : float;
           arm4speed : float;
);
let
    (* This first automaton is used when you need to control the legs and the arm at the same time *)
    automaton
        state Falling
            do
                hipLspeed = setMotor(hipLangle, -.40.0, 60.0);
                hipRspeed = setMotor(hipRangle, 40.0, 60.0);
                kneeLspeed = setMotor(kneeLangle, 100.0, 60.0);
                kneeRspeed = setMotor(kneeRangle, -.100.0, 60.0);
                arm1speed = setMotorPID(arm1angle, -.40.0, 20.0, 0.5, 0.0, 0.2);
                arm2speed = setMotorPID(arm2angle, 30.0, 20.0, 0.7, 0.0, 0.3);
                arm3speed = setMotorPID(arm3angle, 80.0, 20.0, 0.9, 0.0, 0.4);
                arm4speed = setMotorPID(arm4angle, 60.0, 20.0, 1.0, 0.0, 0.5);
            until false then Standard
        state Upside_Down_Init
            do
                (* TODO *)
                hipLspeed = setMotor(hipLangle, -.40.0, 60.0);
                hipRspeed = setMotor(hipRangle, 40.0, 60.0);
                kneeLspeed = setMotor(kneeLangle, 100.0, 60.0);
                kneeRspeed = setMotor(kneeRangle, -.100.0, 60.0);
                arm1speed = setMotor(arm1angle, 0.0, 60.0);
                arm2speed = setMotor(arm2angle, 0.0, 60.0);
                arm3speed = setMotor(arm3angle, 0.0, 60.0);
                arm4speed = setMotor(arm4angle, 0.0, 60.0);

        state Standard
            do
                hipLspeed = setMotor(hipLangle, -.40.0, 60.0);
                hipRspeed = setMotor(hipRangle, 40.0, 60.0);
                kneeLspeed = setMotor(kneeLangle, 100.0, 60.0);
                kneeRspeed = setMotor(kneeRangle, -.100.0, 60.0);
                arm1speed = setMotor(arm1angle, 0.0, 60.0);
                arm2speed = setMotor(arm2angle, 0.0, 60.0);
                arm3speed = setMotor(arm3angle, 0.0, 60.0);
                arm4speed = setMotor(arm4angle, 0.0, 60.0);
    end;
tel
